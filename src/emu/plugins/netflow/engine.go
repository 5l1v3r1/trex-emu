// Copyright (c) 2020 Cisco Systems and/or its affiliates.
// Licensed under the Apache License, Version 2.0 (the "License");
// that can be found in the LICENSE file in the root of the source
// tree.

package netflow

import (
	"encoding/binary"
	"errors"
	"fmt"
	"math"
	"math/rand"

	"github.com/intel-go/fastjson"
)

/* Field Engine offers the possibility to manipulate packets and parts of packets
by generating values in different forms and operations.
An engine has a small context and will generate values from that context */

// FieldEngineIF is a interface that every type of engine/generator should implement
// in order to provive common functionality to the caller. A caller doesn't care which
// type of field he is updating, but all the types must offer common functionality.
type FieldEngineIF interface {
	// Update updates the byte slice it receives with the new generated value.
	// It writes from the beginning of the slice.
	// If the length of the slice is shorter that the length of the variable we are
	// trying to write, it will return an error.
	// It is the responsibility of the caller to provide Update with a long enough
	// slice.
	Update(b []byte) error
	// GetOffset returns the offset of the packet as the interface was provived with.
	// The caller should use GetOffset to provide the interface with the correct
	// byte slice.
	GetOffset() uint16
	// GetSize() returns the size of the variable that the engine will write in
	// the slice byte the next time it will be called. In order to provide a slice
	// long enough, the caller should use GetSize.
	GetSize() uint16
}

// HistogramEntry is an interface for generic types of Histogram Engines.
// HistogramEngine is a fast non uniform pseudo random generator that can generate
// different types of elements. Each entry in this histogram must provide a probability
// for that entry to be chosen and a value for the histogram engine to output.
type HistogramEntry interface {
	// GetProb returns the probability of this entry to be chosen.
	GetProb() uint32
	// GetValue puts in the byte buffer the value that this entry outputs
	// in case it is picked. This value will be generated by the engine.
	// In case the input is incorrect and a value can't be generated, it will
	// return an error.
	GetValue(size uint16) ([]byte, error)
}

/* ------------------------------------------------------------------------------
								UIntEngine
--------------------------------------------------------------------------------*/
// UIntEngine params is a struct a parameters for the UIntEngine.
type UIntEngineParams struct {
	Size      uint16 `json:"size"`   // size of the uint variable in bytes
	Offset    uint16 `json:"offset"` // offset in which to write in the packet
	Op        string `json:"op"`     // operation which provides the generation, can be {inc, dec, rand}
	Step      uint64 `json:"step"`   // step to decrement or increment, rand will be ignored. Default=1.
	MinValue  uint64 `json:"min"`    // minimal value of the domain
	MaxValue  uint64 `json:"max"`    // maximal value of the domain
	InitValue uint64 `json:"init"`   // initial value in the generator, default = min value.
}

// UIntEngine is a field engine which is responsible to generate variables of uint types.
// These types can be of lengths (1, 2, 4, 8) bytes (uint8, uint16, uint32, uint64).
// The next variable can be generated through different operations, a increment of the current value,
// a decrement of the current value, or some random generation.
type UIntEngine struct {
	par       *UIntEngineParams   // params as provided by the caller
	currValue uint64              // current value in the generator
	domainLen uint64              // domain length
	mgr       *FieldEngineManager // field engine manager
}

// maxUInt64 calculates the max between 2 uint64.
func maxUInt64(a, b uint64) (max uint64) {
	if a >= b {
		max = a
	} else {
		max = b
	}
	return max
}

// findValue returns the index of the val item in array arr if it is found and true,
// else -1 and false.
func findValue(arr []uint16, val uint16) (int, bool) {
	for i, item := range arr {
		if item == val {
			return i, true
		}
	}
	return -1, false
}

func CreateUIntEngine(params *fastjson.RawMessage, mgr *FieldEngineManager) (FieldEngineIF, error) {
	// parse the json
	p := UIntEngineParams{Step: 1}
	err := mgr.tctx.UnmarshalValidate(*params, &p)
	if err != nil {
		mgr.counters.invalidJson++
		return nil, err
	}

	// create and return new engine
	return NewUIntEngine(&p, mgr)
}

// NewUintEngine creates a new uint engine
func NewUIntEngine(params *UIntEngineParams, mgr *FieldEngineManager) (*UIntEngine, error) {
	o := new(UIntEngine)
	o.mgr = mgr
	err := o.validateParams(params)
	if err != nil {
		// validate has already set the errors of the manager
		return nil, err
	}
	o.par = params
	o.domainLen = (o.par.MaxValue - o.par.MinValue + 1)
	if o.domainLen == 0 {
		// when min = 0 and max = MaxUint64 domainLen can't be represented on a uint64.
		// So we try to get as close as we can.
		o.domainLen = math.MaxUint64
	}
	if o.par.Step > o.domainLen {
		o.par.Step = o.par.Step % o.domainLen
	}
	o.currValue = maxUInt64(o.par.MinValue, o.par.InitValue)
	return o, nil
}

// ValidateParams validates the parameters of the uint engine.
func (o *UIntEngine) validateParams(params *UIntEngineParams) (err error) {
	err = nil
	if params.MinValue > params.MaxValue {
		err = fmt.Errorf("Min value %v is bigger than max value %v.\n", params.MinValue, params.MaxValue)
		o.mgr.counters.maxSmallerThanMin++
	}
	if params.InitValue != 0 && (params.InitValue < params.MinValue || params.InitValue > params.MaxValue) {
		err = fmt.Errorf("Init value %v must be between [%v - %v].\n", params.InitValue, params.MinValue, params.MaxValue)
		o.mgr.counters.badInitValue++
	}
	sizes := []uint16{1, 2, 4, 8}
	maxPossible := []uint64{math.MaxUint8, math.MaxUint16, math.MaxUint32, math.MaxUint64}
	i, ok := findValue(sizes, params.Size)
	if !ok {
		err = fmt.Errorf("Invalid size %v. Size should be {1, 2, 4, 8}.\n", params.Size)
		o.mgr.counters.invalidSize++
	} else {
		if params.MaxValue > maxPossible[i] {
			err = fmt.Errorf("Max value %v cannot be represented with size %v.\n", params.MaxValue, params.Size)
			o.mgr.counters.sizeTooSmall++
		}
	}
	if params.Op != "inc" && params.Op != "dec" && params.Op != "rand" {
		err = fmt.Errorf("Unsupported operation %v.\n", params.Op)
		o.mgr.counters.badOperation++
	}
	return err
}

// IncValue increments the value according to step
func (o *UIntEngine) IncValue() {
	// Need to be very careful here with overflows.
	left := o.par.MaxValue - o.currValue // this will never overflow as currValue < maxValue
	if o.par.Step <= left {
		// simple increment by step, not overflow of domain
		// step is fixed module size of domain
		o.currValue += o.par.Step
	} else {
		// overflow of domain
		// if here then (step > left) therefore step - left - 1 will not overflow
		o.currValue = o.par.MinValue + (o.par.Step - left - 1) // restart also consumes 1
	}
}

// DecValue decrements the value according to step
func (o *UIntEngine) DecValue() {
	left := o.currValue - o.par.MinValue // this will never overflow as currValue > minValue
	if o.par.Step <= left {
		// no overflow of domain
		// step is fixed module size of domain
		o.currValue -= o.par.Step
	} else {
		// overflow of domain
		// if here then (step > left) therefore step - left - 1 will not overflow
		o.currValue = o.par.MaxValue - (o.par.Step - left - 1) // restart also consumes 1
	}
}

// RandValue generates a random value in the domain [min, max]
func (o *UIntEngine) RandValue() {
	// Generates a uint64 with uniform distribution.
	// Converts the generated value to a value in the domain by adding the modulus of domainLength
	// to the minimal value.
	genValue := rand.Uint64()
	o.currValue = o.par.MinValue + (genValue % o.domainLen)
}

// PerformOp performs the operation, either it is rand, inc or dec.
func (o *UIntEngine) PerformOp() (err error) {
	err = nil
	switch o.par.Op {
	case "inc":
		o.IncValue()
	case "dec":
		o.DecValue()
	case "rand":
		o.RandValue()
	default:
		o.mgr.counters.badOperation++
		err = errors.New("Unrecognized operation")
	}
	return err
}

// Update implements the Update function of FieldEngineIF.
func (o *UIntEngine) Update(b []byte) error {
	if len(b) < int(o.par.Size) {
		o.mgr.counters.bufferTooShort++
		return fmt.Errorf("Provided slice is shorter that the size of the variable to write, want at least %v, have %v.\n", o.par.Size, len(b))
	}
	switch o.par.Size {
	case 1:
		b[0] = uint8(o.currValue)
	case 2:
		binary.BigEndian.PutUint16(b, uint16(o.currValue))
	case 4:
		binary.BigEndian.PutUint32(b, uint32(o.currValue))
	case 8:
		binary.BigEndian.PutUint64(b, o.currValue)
	default:
		o.mgr.counters.invalidSize++
		return errors.New("Size should be 1, 2, 4 or 8.")
	}
	err := o.PerformOp()
	if err != nil {
		// errors already set
		return err
	}
	return nil
}

// GetOffset implements the GetOffset function of FieldEngineIF.
func (o *UIntEngine) GetOffset() uint16 {
	return o.par.Offset
}

// GetSize implements the GetSize function of FieldEngineIF.
func (o *UIntEngine) GetSize() uint16 {
	return o.par.Size
}

/* ------------------------------------------------------------------------------
							HistogramEngine
--------------------------------------------------------------------------------*/
// HistogramEngineCommonParams contains the common params for all the types of
// histogram engines.
type HistogramEngineCommonParams struct {
	Size   uint16 `json:"size"`   // size of the variable in bytes
	Offset uint16 `json:"offset"` // offset in which to write in the packet
}

// HistogramEngineParams is a struct that must be provided to the HistogramEngine
// when creating it.
type HistogramEngineParams struct {
	HistogramEngineCommonParams                  // common params for all the engines
	Entries                     []HistogramEntry // the entries of the histogram
}

// HistogramEngine is a FieldEngine, which contains a non uniform pseudo random
// generator and can generate it's entries as per probability of each entry.
type HistogramEngine struct {
	par           *HistogramEngineParams // params as provided by the caller
	distributions []uint32               // distribution slice
	generator     *NonUniformRandGen     // non uniform random generator of the distribution
	mgr           *FieldEngineManager    // field engine manager

}

// NewHistogramEngine creates a new HistogramEngine from the HistogramEngineParams provided.
func NewHistogramEngine(params *HistogramEngineParams, mgr *FieldEngineManager) (o *HistogramEngine, err error) {
	o = new(HistogramEngine)
	o.buildDistributionSlice(params.Entries)
	o.par = params
	o.mgr = mgr
	o.generator, err = NewNonUniformRandGen(o.distributions)
	if err != nil {
		o.mgr.counters.generatorCreationError++
		return nil, err
	}
	return o, nil
}

func (o *HistogramEngine) buildDistributionSlice(entries []HistogramEntry) {
	for _, entry := range entries {
		o.distributions = append(o.distributions, entry.GetProb())
	}
}

// Update implements the Update function of FieldEngineIF.
func (o *HistogramEngine) Update(b []byte) error {
	if len(b) < int(o.par.Size) {
		o.mgr.counters.bufferTooShort++
		return fmt.Errorf("Provided slice is shorter that the size of the variable to write, want at least %v, have %v.\n", o.par.Size, len(b))
	}
	entryIndex := o.generator.Generate()
	entry := o.par.Entries[entryIndex]
	newValueBytes, err := entry.GetValue(o.par.Size)
	if err != nil {
		o.mgr.counters.invalidHistogramEntry++
		return err
	}
	if len(newValueBytes) < int(o.par.Size) {
		o.mgr.counters.invalidHistogramEntry++
		return fmt.Errorf("New value length is shorter that it should be, want %v, have %v.\n", o.par.Size, len(newValueBytes))
	}
	copiedSize := copy(b[:o.par.Size], newValueBytes[:o.par.Size])
	if copiedSize != int(o.par.Size) {
		o.mgr.counters.badCopyToBuffer++
		return fmt.Errorf("Didn't copy the right amount to the buffer, want %v have %v.\n", o.par.Size, copiedSize)
	}
	return nil
}

// GetOffset implements the GetOffset function of FieldEngineIF.
func (o *HistogramEngine) GetOffset() uint16 {
	return o.par.Offset
}

// GetSize implements the GetSize function of FieldEngineIF.
func (o *HistogramEngine) GetSize() uint16 {
	return o.par.Size
}

/* ------------------------------------------------------------------------------
						Helping Utils for Uint32
--------------------------------------------------------------------------------*/

func putValueInBuffer(size uint16, value uint32) (b []byte, err error) {
	b = make([]byte, size)
	switch size {
	case 1:
		b[0] = uint8(value)
	case 2:
		binary.BigEndian.PutUint16(b, uint16(value))
	case 4:
		binary.BigEndian.PutUint32(b, value)
	default:
		return nil, fmt.Errorf("Invalid size %v in GetValue!\n", size)
	}
	return b, nil
}

/* ------------------------------------------------------------------------------
						HistogramUInt32Entry
--------------------------------------------------------------------------------*/
// HistogramUInt32Entry represents a uint32 which can be used as an entry for the
// HistogramEngine. This entry can be picked with probability prob.
type HistogramUInt32Entry struct {
	V    uint32 `json:"v"`    // a value v of 32 bits
	Prob uint32 `json:"prob"` // probability of this entry
}

// HistogramUInt32Params is used for parsing the input json.
type HistogramUInt32Params struct {
	HistogramEngineCommonParams                        // common params
	Entries                     []HistogramUInt32Entry `json:"entries"` // slice of entries
}

// GetValue puts the value in the byte buffer.
func (o *HistogramUInt32Entry) GetValue(size uint16) (b []byte, err error) {
	return putValueInBuffer(size, o.V)
}

// GetProb returns the probability for this entry to be picked in the histogram engine.
func (o *HistogramUInt32Entry) GetProb() uint32 {
	return o.Prob
}

// CreateHistogramUInt32ListEngine creates an histogram engine of uint 32 from the input json.
func CreateHistogramUInt32Engine(params *fastjson.RawMessage, mgr *FieldEngineManager) (eng FieldEngineIF, err error) {
	// unmarshall the data
	p := HistogramUInt32Params{}
	err = fastjson.Unmarshal(*params, &p)
	if err != nil {
		mgr.counters.invalidJson++
		return nil, err
	}

	// create general params
	var histParams HistogramEngineParams
	histParams.Size = p.Size
	histParams.Offset = p.Offset
	for i := range p.Entries {
		switch p.Size {
		case 1:
			if p.Entries[i].V > 0xFF {
				mgr.counters.invalidSize++
				return nil, fmt.Errorf("Value %v can't be represented with %v bytes\n.", p.Entries[i].V, p.Size)
			}
		case 2:
			if p.Entries[i].V > 0xFFFF {
				mgr.counters.invalidSize++
				return nil, fmt.Errorf("Value %v can't be represented with %v bytes\n.", p.Entries[i].V, p.Size)
			}
		case 8:
			mgr.counters.invalidSize++
			return nil, fmt.Errorf("Invalid size %v with type of engine.\n", p.Size)
		}
		histParams.Entries = append(histParams.Entries, &p.Entries[i])
	}

	// create and return new engine
	return NewHistogramEngine(&histParams, mgr)
}

/* ------------------------------------------------------------------------------
						HistogramUInt32RangeEntry
--------------------------------------------------------------------------------*/
// HistogramUInt32RangeEntry represents a range of uint32 which can be used as an
// entry for the HistogramEngine. This entry can be picked with probability prob.
// If the entry is picked, a value in the range will be generated uniformly.
type HistogramUInt32RangeEntry struct {
	Min  uint32 `json:"min"`  // lower bound of the range
	Max  uint32 `json:"max"`  // higher bound of the range
	Prob uint32 `json:"prob"` // probability of this entry
}

// HistogramUInt32RangeParams is used for parsing the input json.
type HistogramUInt32RangeParams struct {
	HistogramEngineCommonParams                             // common params
	Entries                     []HistogramUInt32RangeEntry `json:"entries"` // slice of entries
}

// GetValue generates uniformly a value in the range and puts it in the byte buffer.
func (o *HistogramUInt32RangeEntry) GetValue(size uint16) (b []byte, err error) {
	if o.Max < o.Min {
		return nil, fmt.Errorf("Max %v is smaller than min %v in HistogramRuneRangeEntry.\n", o.Max, o.Min)
	}
	v := rand.Uint32()                    // generate random 32 bytes
	v = o.Min + (v % (o.Max - o.Min + 1)) // scale it to the domain
	return putValueInBuffer(size, v)
}

// GetProb returns the probability for this entry to be picked in the histogram engine.
func (o *HistogramUInt32RangeEntry) GetProb() uint32 {
	return o.Prob
}

// CreateHistogramUInt32RangeEngine creates an histogram engine of uint32 range from the input json.
func CreateHistogramUInt32RangeEngine(params *fastjson.RawMessage, mgr *FieldEngineManager) (eng FieldEngineIF, err error) {
	// unmarshall the data
	p := HistogramUInt32RangeParams{}
	err = fastjson.Unmarshal(*params, &p)
	if err != nil {
		mgr.counters.invalidJson++
		return nil, err
	}

	// create general params
	var histParams HistogramEngineParams
	histParams.Size = p.Size
	histParams.Offset = p.Offset
	for i := range p.Entries {
		if p.Entries[i].Min > p.Entries[i].Max {
			mgr.counters.maxSmallerThanMin++
			return nil, fmt.Errorf("Min %v bigger than max %v in entry #%v.\n", p.Entries[i].Min, p.Entries[i].Max, i)
		}
		switch p.Size {
		case 1:
			if p.Entries[i].Max > 0xFF {
				mgr.counters.invalidSize++
				return nil, fmt.Errorf("Max %v can't be represented with %v bytes\n.", p.Entries[i].Max, p.Size)
			}
		case 2:
			if p.Entries[i].Max > 0xFFFF {
				mgr.counters.invalidSize++
				return nil, fmt.Errorf("Max %v can't be represented with %v bytes\n.", p.Entries[i].Max, p.Size)
			}
		case 8:
			mgr.counters.invalidSize++
			return nil, fmt.Errorf("Invalid size %v with type of engine.\n", p.Size)
		}

		histParams.Entries = append(histParams.Entries, &p.Entries[i])
	}

	// create and return new engine
	return NewHistogramEngine(&histParams, mgr)
}

/* ------------------------------------------------------------------------------
						HistogramUInt32ListEntry
--------------------------------------------------------------------------------*/
// HistogramUInt32ListEntry represents a list of uint32 which can be used as an
// entry for the HistogramEngine. This entry can be picked with probability prob.
// If the entry is picked, a value in the list will be selected uniformly.
type HistogramUInt32ListEntry struct {
	List []uint32 `json:"list"` // a list from where the element will be picked
	Prob uint32   `json:"prob"` // probability of this entry
}

// HistogramUInt32ListParams is used for parsing the input json.
type HistogramUInt32ListParams struct {
	HistogramEngineCommonParams                            // common params
	Entries                     []HistogramUInt32ListEntry `json:"entries"` // slice of entries
}

// GetValue picks a random value from the list and puts it in the byte buffer.
func (o *HistogramUInt32ListEntry) GetValue(size uint16) (b []byte, err error) {
	if o.List == nil || len(o.List) == 0 {
		return nil, fmt.Errorf("Empty list in HistogramUInt32ListEntry.\n")
	}
	index := rand.Intn(len(o.List))
	return putValueInBuffer(size, o.List[index])
}

// GetProb returns the probability for this entry to be picked in the histogram engine.
func (o *HistogramUInt32ListEntry) GetProb() uint32 {
	return o.Prob
}

// CreateHistogramUInt32ListEngine creates an histogram engine of uint32 list from the input json.
func CreateHistogramUInt32ListEngine(params *fastjson.RawMessage, mgr *FieldEngineManager) (eng FieldEngineIF, err error) {
	// unmarshall the data
	p := HistogramUInt32ListParams{}
	err = fastjson.Unmarshal(*params, &p)
	if err != nil {
		mgr.counters.invalidJson++
		return nil, err
	}

	// create general params
	var histParams HistogramEngineParams
	histParams.Size = p.Size
	histParams.Offset = p.Offset
	for i := range p.Entries {
		if len(p.Entries[i].List) == 0 {
			mgr.counters.emptyList++
			return nil, fmt.Errorf("Entry # %v contains an empty list.\n", i)
		}
		for j := range p.Entries[i].List {
			v := p.Entries[i].List[j]
			switch p.Size {
			case 1:
				if v > 0xFF {
					mgr.counters.invalidSize++
					return nil, fmt.Errorf("List value %v can't be represented with %v bytes\n.", v, p.Size)
				}
			case 2:
				if v > 0xFFFF {
					mgr.counters.invalidSize++
					return nil, fmt.Errorf("List value %v can't be represented with %v bytes\n.", v, p.Size)
				}
			case 8:
				mgr.counters.invalidSize++
				return nil, fmt.Errorf("Invalid size %v with type of engine.\n", p.Size)
			}
		}
		histParams.Entries = append(histParams.Entries, &p.Entries[i])
	}

	// create and return new engine
	return NewHistogramEngine(&histParams, mgr)
}

/* ------------------------------------------------------------------------------
						HistogramUInt64Entry
--------------------------------------------------------------------------------*/
// HistogramUInt64Entry represents a uint64 which can be used as an entry for the
// HistogramEngine. This entry can be picked with probability prob.
type HistogramUInt64Entry struct {
	V    uint64 `json:"v"`    // a value v of 64 bits
	Prob uint32 `json:"prob"` // probability of this entry
}

// HistogramUInt64Params is used for parsing the input json.
type HistogramUInt64Params struct {
	HistogramEngineCommonParams                        // common params
	Entries                     []HistogramUInt64Entry `json:"entries"` // slice of entries
}

// GetValue puts the value in the byte buffer.
func (o *HistogramUInt64Entry) GetValue(size uint16) (b []byte, err error) {
	if size != 8 {
		return nil, fmt.Errorf("Size in HistogramUInt64Entry GetValue is %v, want %v.\n", size, 8)
	}
	b = make([]byte, size)
	binary.BigEndian.PutUint64(b, o.V)
	return b, nil
}

// GetProb returns the probability for this entry to be picked in the histogram engine.
func (o *HistogramUInt64Entry) GetProb() uint32 {
	return o.Prob
}

// CreateHistogramUInt64Engine creates an histogram engine of uint64 from the input json.
func CreateHistogramUInt64Engine(params *fastjson.RawMessage, mgr *FieldEngineManager) (eng FieldEngineIF, err error) {
	// unmarshall the data
	p := HistogramUInt64Params{}
	err = fastjson.Unmarshal(*params, &p)
	if err != nil {
		mgr.counters.invalidJson++
		return nil, err
	}
	if p.Size != 8 {
		mgr.counters.invalidSize++
		return nil, fmt.Errorf("Invalid size %v with type of engine.\n", p.Size)
	}

	// create general params
	var histParams HistogramEngineParams
	histParams.Size = p.Size
	histParams.Offset = p.Offset
	for i := range p.Entries {
		histParams.Entries = append(histParams.Entries, &p.Entries[i])
	}

	// create and return new engine
	return NewHistogramEngine(&histParams, mgr)
}

/* ------------------------------------------------------------------------------
						HistogramUInt64RangeEntry
--------------------------------------------------------------------------------*/
// HistogramUInt64RangeEntry represents a range of uint64 which can be used as an
// entry for the HistogramEngine. This entry can be picked with probability prob.
// If the entry is picked, a value in the range will be generated uniformly.
type HistogramUInt64RangeEntry struct {
	Min  uint64 `json:"min"`  // lower bound of the range
	Max  uint64 `json:"max"`  // higher bound of the range
	Prob uint32 `json:"prob"` // probability of this entry
}

// HistogramUInt64RangeParams is used for parsing the input json.
type HistogramUInt64RangeParams struct {
	HistogramEngineCommonParams                             // common params
	Entries                     []HistogramUInt64RangeEntry `json:"entries"` // slice of entries
}

// GetValue generates uniformly a value in the range and puts it in the byte buffer.
func (o *HistogramUInt64RangeEntry) GetValue(size uint16) (b []byte, err error) {
	if size != 8 {
		return nil, fmt.Errorf("Size in HistogramUInt64Entry GetValue is %v, want %v.\n", size, 8)
	}
	if o.Max < o.Min {
		return nil, fmt.Errorf("Max %v is smaller than min %v in HistogramRuneRangeEntry.\n", o.Max, o.Min)
	}
	b = make([]byte, size)
	v := rand.Uint64()                    // generate random 32 bytes
	v = o.Min + (v % (o.Max - o.Min + 1)) // scale it to the domain
	binary.BigEndian.PutUint64(b, v)      // put it in the bytes buffer
	return b, nil
}

// GetProb returns the probability for this entry to be picked in the histogram engine.
func (o *HistogramUInt64RangeEntry) GetProb() uint32 {
	return o.Prob
}

// CreateHistogramUInt64RangeEngine creates an histogram engine of uint64 range from the input json.
func CreateHistogramUInt64RangeEngine(params *fastjson.RawMessage, mgr *FieldEngineManager) (eng FieldEngineIF, err error) {
	// unmarshall the data
	p := HistogramUInt64RangeParams{}
	err = fastjson.Unmarshal(*params, &p)
	if err != nil {
		mgr.counters.invalidJson++
		return nil, err
	}

	if p.Size != 8 {
		mgr.counters.invalidSize++
		return nil, fmt.Errorf("Invalid size %v with type of engine.\n", p.Size)
	}

	// create general params
	var histParams HistogramEngineParams
	histParams.Size = p.Size
	histParams.Offset = p.Offset
	for i := range p.Entries {
		if p.Entries[i].Min > p.Entries[i].Max {
			mgr.counters.maxSmallerThanMin++
			return nil, fmt.Errorf("Min %v bigger than max %v in entry #%v.\n", p.Entries[i].Min, p.Entries[i].Max, i)
		}
		histParams.Entries = append(histParams.Entries, &p.Entries[i])
	}

	// create and return new engine
	return NewHistogramEngine(&histParams, mgr)
}

/* ------------------------------------------------------------------------------
						HistogramUInt64ListEntry
--------------------------------------------------------------------------------*/
// HistogramUInt64ListEntry represents a list of uint64 which can be used as an
// entry for the HistogramEngine. This entry can be picked with probability prob.
// If the entry is picked, a value in the list will be selected uniformly.
type HistogramUInt64ListEntry struct {
	List []uint64 `json:"list"` // a list from where the element will be picked
	Prob uint32   `json:"prob"` // probability of this entry
}

// HistogramUInt64ListParams is used for parsing the input json.
type HistogramUInt64ListParams struct {
	HistogramEngineCommonParams                            // common params
	Entries                     []HistogramUInt64ListEntry `json:"entries"` // slice of entries
}

// GetValue picks a random value from the list and puts it in the byte buffer.
func (o *HistogramUInt64ListEntry) GetValue(size uint16) (b []byte, err error) {
	if size != 8 {
		return nil, fmt.Errorf("Size in HistogramUInt64Entry GetValue is %v, want %v.\n", size, 8)
	}
	if o.List == nil || len(o.List) == 0 {
		return nil, fmt.Errorf("Empty list in HistogramUInt32ListEntry.\n")
	}
	b = make([]byte, size)
	index := rand.Intn(len(o.List))
	binary.BigEndian.PutUint64(b, o.List[index])
	return b, nil
}

// GetProb returns the probability for this entry to be picked in the histogram engine.
func (o *HistogramUInt64ListEntry) GetProb() uint32 {
	return o.Prob
}

// CreateHistogramUInt32ListEngine creates an histogram engine of uint32 list from the input json.
func CreateHistogramUInt64ListEngine(params *fastjson.RawMessage, mgr *FieldEngineManager) (eng FieldEngineIF, err error) {
	// unmarshall the data
	p := HistogramUInt64ListParams{}
	err = fastjson.Unmarshal(*params, &p)
	if err != nil {
		mgr.counters.invalidJson++
		return nil, err
	}

	if p.Size != 8 {
		mgr.counters.invalidSize++
		return nil, fmt.Errorf("Invalid size %v with type of engine.\n", p.Size)
	}

	// create general params
	var histParams HistogramEngineParams
	histParams.Size = p.Size
	histParams.Offset = p.Offset
	for i := range p.Entries {
		if len(p.Entries[i].List) == 0 {
			mgr.counters.emptyList++
			return nil, fmt.Errorf("Entry # %v contains an empty list.\n", i)
		}
		histParams.Entries = append(histParams.Entries, &p.Entries[i])
	}

	// create and return new engine
	return NewHistogramEngine(&histParams, mgr)
}

func init() {
	// Register all the field engine types.
	fieldEngineRegister("uint", CreateUIntEngine)
	fieldEngineRegister("histogram_uint8", CreateHistogramUInt32Engine)
	fieldEngineRegister("histogram_uint8_range", CreateHistogramUInt32RangeEngine)
	fieldEngineRegister("histogram_uint8_list", CreateHistogramUInt32ListEngine)
	fieldEngineRegister("histogram_uint16", CreateHistogramUInt32Engine)
	fieldEngineRegister("histogram_uint16_range", CreateHistogramUInt32RangeEngine)
	fieldEngineRegister("histogram_uint16_list", CreateHistogramUInt32ListEngine)
	fieldEngineRegister("histogram_uint32", CreateHistogramUInt32Engine)
	fieldEngineRegister("histogram_uint32_range", CreateHistogramUInt32RangeEngine)
	fieldEngineRegister("histogram_uint32_list", CreateHistogramUInt32ListEngine)
	fieldEngineRegister("histogram_uint64", CreateHistogramUInt64Engine)
	fieldEngineRegister("histogram_uint64_range", CreateHistogramUInt64RangeEngine)
	fieldEngineRegister("histogram_uint64_list", CreateHistogramUInt64ListEngine)

}
